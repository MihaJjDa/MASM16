include io.asm

stack segment stack
	dw 128 dup (?)
stack ends

data segment
	HELLO db 'Пучкин Данила, 112 группа, задача 4.1', '$'
	WEL db 'Введите формулу с точкой в конце:', '$'
	GB db 'Результат: ', '$'

data ends

code segment 'code'
	assume ss:stack, ds:data, cs:code

start:
	mov ax,data
	mov ds,ax
	
	lea DX, HELLO
	outstr
	newline
	
	lea DX, WEL
	outstr
	newline
	
	xor DX, DX
	push DX; на случай

L:	inch DL
	cmp DL, '.'; ищем конец
	jNE L1; если не конец - работаем дальше
	jmp ex; иначе на выход

L1:	cmp DL, '('; пропускаем открывающие скобки
	jE L

	cmp DL, ')'; ищем конец очередного выражения
	jNE L2; если не конец - обрабатываем попавшийся знак или цифру
	pop CX; иначе извелкаем вторую цифру
	pop BX; знак
	pop AX; первую цифру
	cmp BL, '+'; определяем знак
	jE A; если + => складываем
	sub AX, CX; иначе вычитаем
	jmp short B; и к стеку
A:	add AX, CX; складываем и к стеку
B:	push AX; заносим результат
	jmp L; работаем в цикле далее
	
L2:	cmp DL, '+'; ищем не цифру
	jE P; не цифра - заносим в стек
	cmp DL, '-'; ищем не цифру
	jE P; не цифра - заносим в стек
	sub DL, '0'; цифра - делаем из символа цифры саму цифру
P:	push DX; и в стек
	jmp L; работаем в цикле
	
ex: lea DX, GB
	outstr
	
	pop DX; извлечем результат
	outint DX
	newline
	
	pop DX; уберем 0
	mov AH, 8; удерживать
	int 21h;   ответ
	
    finish
code ends
    end start 
